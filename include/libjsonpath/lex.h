#ifndef LIBJSONPATH_LEX_H_
#define LIBJSONPATH_LEX_H_

#include "libjsonpath/tokens.h"
#include <deque>
#include <optional>
#include <stack>
#include <string>
#include <unordered_set>

namespace libjsonpath {

enum class State {
  error,
  none,
  lexRoot,
  lexSegment,
  lexDescendantSelection,
  lexDotSelector,
  lexInsideBracketedSelection,
  lexInsideFilter,
  lexInsideSingleQuotedString,
  lexInsideDoubleQuotedString,
  lexInsideSingleQuotedFilterString,
  lexInsideDoubleQuotedFilterString,
};

class Lexer {
public:
  Lexer(std::string_view query);
  // TODO: copy constructor
  // TODO: move constructor
  // TODO: assignment constructor

  const std::string_view query_;

  // Start the state machine.
  void run();

  // Tokens generated by the lexer after calling _run()_.
  const std::deque<Token>& tokens() { return tokens_; };

  // The error message produced by _run()_, or an empty string if there
  // was no error.
  const std::string& error_message() { return error_; };

private:
  const std::string::size_type length_;
  std::string error_{};
  std::deque<Token> tokens_{};

  // A JSONPath filter expression can contain _filter queries_, which
  // are fully-formed JSONPath queries relative to the current JSON
  // node or the document root. So, considering that JSONPath queries
  // can be arbitrarily nested in this way, we must keep track of the
  // number of nested filter selectors in order to yield control back
  // to the appropriate lexer state function.
  int filter_nesting_level_{0};

  // A running count of parentheses for each, possibly nested, filter
  // function call. If the stack is empty, we are not in a filter
  // function call. Remember that function arguments can use arbitrarily
  // nested parentheses.
  std::stack<int> paren_stack_{};

  // Index of the start of the current token being scanned.
  std::string::size_type start_{0};

  // Index of the character currently being scanned.
  std::string::size_type pos_{0};

  // The set of characters that are considered to be whitespace.
  static inline const std::unordered_set<char> whitespace{
      ' ', '\n', '\t', '\r'};

  // The set of characters that are allowed to follow a '\' to form
  // and escape sequence in a string literal.
  static inline const std::unordered_set<char> escapes{
      'b', 'f', 'n', 'r', 't', 'u', '/'};

  static inline const std::unordered_set<char> digits{
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

  static inline const std::unordered_set<char> sign{'+', '-'};

  static inline const std::unordered_set<char> function_name_first{'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z'};

  static inline const std::unordered_set<char> function_name_char{'0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      '_',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z'};

  static inline const std::unordered_set<char> name_first{'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      '_',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z'};

  static inline const std::unordered_set<char> name_char{'0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      '_',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z'};

  // Return the next character from the query string, wrapped in an
  // optional object, and advance the current position. If the optional
  // object is empty, we have reached the end of the query string.
  std::optional<char> next();

  // Return the next character from the query string - wrapped in an
  // optional object - without advancing _pos_. If the optional object
  // is empty, we have reached the end of the query string.
  std::optional<char> peek();

  // Push a new token of type _t_ and value between _start_ and _pos_
  // to the token list.
  void emit(TokenType t);

  bool accept(const char ch);
  bool accept(const std::unordered_set<char>& valid);
  bool accept_run(const std::unordered_set<char>& valid);
  bool accept_name(); // Advance the lexer until we find a non-name char.

  // Return a string view starting from the current position.
  std::string_view view() const;

  void backup();            // Go back one character, if _pos_ > _start_.
  void ignore();            // Consume characters between _start_ and _pos_.
  bool ignore_whitespace(); // Consume whitespace characters from _start_.

  void error(std::string_view message);

  State lexRoot();
  State lexSegment();
  State lexDescendantSelection();
  State lexDotSelector();
  State lexInsideBracketedSelection();
  State lexInsideFilter();
  State lexInsideSingleQuotedString();
  State lexInsideDoubleQuotedString();
  State lexInsideSingleQuotedFilterString();
  State lexInsideDoubleQuotedFilterString();
};

} // namespace libjsonpath

#endif