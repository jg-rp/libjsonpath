#ifndef LIBJSONPATH_LEX_H_
#define LIBJSONPATH_LEX_H_

#include "libjsonpath/tokens.h"
#include <deque>
#include <optional>
#include <stack>
#include <string>
#include <unordered_set>

namespace libjsonpath {

// TODO: settle on a naming convention

class Lexer {
public:
  Lexer(std::string_view query);
  // TODO: copy constructor
  // TODO: move constructor
  // TODO: assignment constructor

  const std::string_view query_;

  // Start the state machine.
  void run();

  // Tokens generated by the lexer after calling _run()_.
  const std::deque<Token>& tokens() { return m_tokens; };

  // The error message produced by _run()_, or an empty string if there
  // was no error.
  const std::string& error_message() { return m_error; };

private:
  enum State {
    ERROR,
    NONE,
    LEX_ROOT,
    LEX_SEGMENT,
    LEX_DESCENDANT_SELECTION,
    LEX_DOT_SELECTOR,
    LEX_INSIDE_BRACKETED_SELECTION,
    LEX_INSIDE_FILTER,
    LEX_INSIDE_SINGLE_QUOTED_STRING,
    LEX_INSIDE_DOUBLE_QUOTED_STRING,
    LEX_INSIDE_SINGLE_QUOTED_FILTER_STRING,
    LEX_INSIDE_DOUBLE_QUOTED_FILTER_STRING,
  };

  const std::string::size_type m_length;
  std::string m_error{};
  std::deque<Token> m_tokens{};

  // A JSONPath filter expression can contain _filter queries_, which
  // are fully-formed JSONPath queries relative to the current JSON
  // node or the document root. So, considering that JSONPath queries
  // can be arbitrarily nested in this way, we must keep track of the
  // number of nested filter selectors in order to yield control back
  // to the appropriate lexer state function.
  int m_filter_nesting_level{0};

  // A running count of parentheses for each, possibly nested, filter
  // function call. If the stack is empty, we are not in a filter
  // function call. Remember that function arguments can use arbitrarily
  // nested parentheses.
  std::stack<int> m_paren_stack{};

  // Index of the start of the current token being scanned.
  std::string::size_type m_start{0};

  // Index of the character currently being scanned.
  std::string::size_type m_pos{0};

  // The set of characters that are considered to be whitespace.
  static inline const std::unordered_set<char> s_whitespace{
      ' ', '\n', '\t', '\r'};

  // The set of characters that are allowed to follow a '\' to form
  // and escape sequence in a string literal.
  static inline const std::unordered_set<char> s_escapes{
      'b', 'f', 'n', 'r', 't', 'u', '/'};

  static inline const std::unordered_set<char> s_digits{
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

  static inline const std::unordered_set<char> s_sign{'+', '-'};

  static inline const std::unordered_set<char> s_function_name_first{'a', 'b',
      'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
      'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};

  static inline const std::unordered_set<char> s_function_name_char{'0', '1',
      '2', '3', '4', '5', '6', '7', '8', '9', '_', 'a', 'b', 'c', 'd', 'e', 'f',
      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
      'v', 'w', 'x', 'y', 'z'};

  static inline const std::unordered_set<char> s_name_first{'A', 'B', 'C', 'D',
      'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
      'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
      'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
      'w', 'x', 'y', 'z'};

  static inline const std::unordered_set<char> s_name_char{'0', '1', '2', '3',
      '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
      'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
      'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
      'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};

  // Return the next character from the query string, wrapped in an
  // optional object, and advance the current position. If the optional
  // object is empty, we have reached the end of the query string.
  std::optional<char> next();

  // Return the next character from the query string - wrapped in an
  // optional object - without advancing _pos_. If the optional object
  // is empty, we have reached the end of the query string.
  std::optional<char> peek();

  // Push a new token of type _t_ and value between _start_ and _pos_
  // to the token list.
  void emit(TokenType t);

  bool accept(const char ch);
  bool accept(const std::unordered_set<char>& valid);
  bool accept_run(const std::unordered_set<char>& valid);
  bool accept_name(); // Advance the lexer until we find a non-name char.

  // Return a string view starting from the current position.
  std::string_view view() const;

  void backup();            // Go back one character, if _pos_ > _start_.
  void ignore();            // Consume characters between _start_ and _pos_.
  bool ignore_whitespace(); // Consume whitespace characters from _start_.

  void error(std::string_view message);

  State lex_root();
  State lex_segment();
  State lex_descendant_selection();
  State lex_dot_selector();
  State lex_inside_bracketed_selection();
  State lex_inside_filter();
  State lex_inside_single_quoted_string();
  State lex_inside_double_quoted_string();
  State lex_inside_single_quoted_filter_string();
  State lex_inside_double_quoted_filter_string();
};

} // namespace libjsonpath

#endif